//------------------------------------------------------------------------------
// AXI4-Lite Sequence Library - Generated by UVMForge
//------------------------------------------------------------------------------

class {{ prefix }}_base_seq extends uvm_sequence #({{ prefix }}_seq_item);
    `uvm_object_utils({{ prefix }}_base_seq)
    
    function new(string name = "{{ prefix }}_base_seq");
        super.new(name);
    endfunction
    
    virtual task write(bit [{{ addr_width }}-1:0] addr, bit [{{ data_width }}-1:0] data);
        {{ prefix }}_seq_item req = {{ prefix }}_seq_item::type_id::create("req");
        start_item(req);
        req.trans_type = AXI_WRITE;
        req.addr = addr;
        req.data = data;
        req.strb = '1;
        finish_item(req);
    endtask
    
    virtual task read(bit [{{ addr_width }}-1:0] addr, output bit [{{ data_width }}-1:0] data);
        {{ prefix }}_seq_item req = {{ prefix }}_seq_item::type_id::create("req");
        start_item(req);
        req.trans_type = AXI_READ;
        req.addr = addr;
        finish_item(req);
        data = req.rdata;
    endtask
endclass : {{ prefix }}_base_seq

class {{ prefix }}_random_seq extends {{ prefix }}_base_seq;
    `uvm_object_utils({{ prefix }}_random_seq)
    rand int num_trans;
    constraint num_trans_c { num_trans inside {[10:50]}; }
    
    function new(string name = "{{ prefix }}_random_seq");
        super.new(name);
    endfunction
    
    virtual task body();
        {{ prefix }}_seq_item req;
        `uvm_info(get_type_name(), $sformatf("Running %0d transactions", num_trans), UVM_MEDIUM)
        repeat (num_trans) begin
            req = {{ prefix }}_seq_item::type_id::create("req");
            start_item(req);
            assert(req.randomize());
            finish_item(req);
        end
    endtask
endclass : {{ prefix }}_random_seq

{% if has_registers %}
class {{ prefix }}_reg_seq extends {{ prefix }}_base_seq;
    `uvm_object_utils({{ prefix }}_reg_seq)
    
    function new(string name = "{{ prefix }}_reg_seq");
        super.new(name);
    endfunction
    
    virtual task body();
        bit [{{ data_width }}-1:0] rdata;
        `uvm_info(get_type_name(), "Testing all registers", UVM_MEDIUM)
{% for reg in registers %}
{% if reg.is_writable %}
        write({{ reg.address_hex }}, 32'hDEAD_BEEF);
{% endif %}
{% if reg.is_readable %}
        read({{ reg.address_hex }}, rdata);
        `uvm_info(get_type_name(), $sformatf("{{ reg.name }} = 0x%0h", rdata), UVM_MEDIUM)
{% endif %}
{% endfor %}
    endtask
endclass : {{ prefix }}_reg_seq
{% endif %}
