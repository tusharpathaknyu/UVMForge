//------------------------------------------------------------------------------
// APB Scoreboard - Generated by UVMForge
//------------------------------------------------------------------------------

class {{ prefix }}_scoreboard extends uvm_scoreboard;
    
    `uvm_component_utils({{ prefix }}_scoreboard)
    
    // Analysis export
    uvm_analysis_imp #({{ prefix }}_seq_item, {{ prefix }}_scoreboard) ap;
    
    // Reference model - register storage
    bit [{{ data_width }}-1:0] reg_model[bit [{{ addr_width }}-1:0]];
    
    // Statistics
    int num_writes;
    int num_reads;
    int num_errors;
    int num_matches;
    
    // Constructor
    function new(string name = "{{ prefix }}_scoreboard", uvm_component parent = null);
        super.new(name, parent);
        ap = new("ap", this);
    endfunction
    
    // Build phase - initialize register model
    virtual function void build_phase(uvm_phase phase);
        super.build_phase(phase);
        
{% for reg in registers %}
        reg_model[{{ reg.address_hex }}] = {{ reg.reset_value_hex }};  // {{ reg.name }}
{% endfor %}
    endfunction
    
    // Write function - called when monitor sends transaction
    virtual function void write({{ prefix }}_seq_item txn);
        bit [{{ data_width }}-1:0] expected;
        
        if (txn.trans_type == APB_WRITE) begin
            num_writes++;
            
            // Update reference model
            if (is_writable(txn.addr)) begin
                reg_model[txn.addr] = txn.data;
                `uvm_info(get_type_name(), 
                    $sformatf("WRITE: addr=0x%0h data=0x%0h", txn.addr, txn.data), UVM_HIGH)
            end
        end
        else begin
            num_reads++;
            
            // Check read data
            if (reg_model.exists(txn.addr)) begin
                expected = reg_model[txn.addr];
                
                if (txn.rdata === expected) begin
                    num_matches++;
                    `uvm_info(get_type_name(),
                        $sformatf("READ MATCH: addr=0x%0h data=0x%0h", txn.addr, txn.rdata), UVM_HIGH)
                end
                else begin
                    num_errors++;
                    `uvm_error(get_type_name(),
                        $sformatf("READ MISMATCH: addr=0x%0h exp=0x%0h got=0x%0h", 
                                  txn.addr, expected, txn.rdata))
                end
            end
        end
    endfunction
    
    // Check if address is writable
    virtual function bit is_writable(bit [{{ addr_width }}-1:0] addr);
        case (addr)
{% for reg in registers %}
{% if reg.is_writable %}
            {{ reg.address_hex }}: return 1;  // {{ reg.name }}
{% else %}
            {{ reg.address_hex }}: return 0;  // {{ reg.name }} (read-only)
{% endif %}
{% endfor %}
            default: return 1;
        endcase
    endfunction
    
    // Report phase
    virtual function void report_phase(uvm_phase phase);
        `uvm_info(get_type_name(), "========== SCOREBOARD SUMMARY ==========", UVM_NONE)
        `uvm_info(get_type_name(), $sformatf("  Writes:  %0d", num_writes), UVM_NONE)
        `uvm_info(get_type_name(), $sformatf("  Reads:   %0d", num_reads), UVM_NONE)
        `uvm_info(get_type_name(), $sformatf("  Matches: %0d", num_matches), UVM_NONE)
        `uvm_info(get_type_name(), $sformatf("  Errors:  %0d", num_errors), UVM_NONE)
        `uvm_info(get_type_name(), "========================================", UVM_NONE)
        
        if (num_errors > 0)
            `uvm_error(get_type_name(), "TEST FAILED - Scoreboard errors detected")
        else
            `uvm_info(get_type_name(), "TEST PASSED", UVM_NONE)
    endfunction
    
endclass : {{ prefix }}_scoreboard
