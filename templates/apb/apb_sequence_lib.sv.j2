//------------------------------------------------------------------------------
// APB Sequence Library - Generated by UVMForge
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Base Sequence
//------------------------------------------------------------------------------
class {{ prefix }}_base_seq extends uvm_sequence #({{ prefix }}_seq_item);
    
    `uvm_object_utils({{ prefix }}_base_seq)
    
    function new(string name = "{{ prefix }}_base_seq");
        super.new(name);
    endfunction
    
    // Helper task: Write to address
    virtual task write(bit [{{ addr_width }}-1:0] addr, bit [{{ data_width }}-1:0] data);
        {{ prefix }}_seq_item req;
        req = {{ prefix }}_seq_item::type_id::create("req");
        start_item(req);
        req.trans_type = APB_WRITE;
        req.addr = addr;
        req.data = data;
        finish_item(req);
    endtask
    
    // Helper task: Read from address
    virtual task read(bit [{{ addr_width }}-1:0] addr, output bit [{{ data_width }}-1:0] data);
        {{ prefix }}_seq_item req;
        req = {{ prefix }}_seq_item::type_id::create("req");
        start_item(req);
        req.trans_type = APB_READ;
        req.addr = addr;
        finish_item(req);
        data = req.rdata;
    endtask
    
endclass : {{ prefix }}_base_seq

//------------------------------------------------------------------------------
// Random Sequence
//------------------------------------------------------------------------------
class {{ prefix }}_random_seq extends {{ prefix }}_base_seq;
    
    `uvm_object_utils({{ prefix }}_random_seq)
    
    rand int num_trans;
    
    constraint num_trans_c {
        num_trans inside {[10:50]};
    }
    
    function new(string name = "{{ prefix }}_random_seq");
        super.new(name);
    endfunction
    
    virtual task body();
        {{ prefix }}_seq_item req;
        
        `uvm_info(get_type_name(), $sformatf("Running %0d random transactions", num_trans), UVM_MEDIUM)
        
        repeat (num_trans) begin
            req = {{ prefix }}_seq_item::type_id::create("req");
            start_item(req);
            if (!req.randomize())
                `uvm_error(get_type_name(), "Randomization failed")
            finish_item(req);
        end
    endtask
    
endclass : {{ prefix }}_random_seq

{% if has_registers %}
//------------------------------------------------------------------------------
// Register Access Sequence
//------------------------------------------------------------------------------
class {{ prefix }}_reg_seq extends {{ prefix }}_base_seq;
    
    `uvm_object_utils({{ prefix }}_reg_seq)
    
    function new(string name = "{{ prefix }}_reg_seq");
        super.new(name);
    endfunction
    
    virtual task body();
        bit [{{ data_width }}-1:0] rdata;
        
        `uvm_info(get_type_name(), "Testing all registers", UVM_MEDIUM)
        
{% for reg in registers %}
        // Test {{ reg.name }} register ({{ reg.access }})
        `uvm_info(get_type_name(), "Testing {{ reg.name }} @ {{ reg.address_hex }}", UVM_MEDIUM)
{% if reg.is_writable %}
        write({{ reg.address_hex }}, 32'hA5A5_A5A5);
{% endif %}
{% if reg.is_readable %}
        read({{ reg.address_hex }}, rdata);
        `uvm_info(get_type_name(), $sformatf("{{ reg.name }} = 0x%0h", rdata), UVM_MEDIUM)
{% endif %}
        
{% endfor %}
    endtask
    
endclass : {{ prefix }}_reg_seq

//------------------------------------------------------------------------------
// Write-Read-Back Sequence
//------------------------------------------------------------------------------
class {{ prefix }}_wr_rd_seq extends {{ prefix }}_base_seq;
    
    `uvm_object_utils({{ prefix }}_wr_rd_seq)
    
    function new(string name = "{{ prefix }}_wr_rd_seq");
        super.new(name);
    endfunction
    
    virtual task body();
        bit [{{ data_width }}-1:0] wdata, rdata;
        
        `uvm_info(get_type_name(), "Write-Read-Back test on RW registers", UVM_MEDIUM)
        
{% for reg in registers %}
{% if reg.access == "RW" %}
        // Test {{ reg.name }}
        wdata = $urandom();
        write({{ reg.address_hex }}, wdata);
        read({{ reg.address_hex }}, rdata);
        if (rdata !== wdata)
            `uvm_error(get_type_name(), $sformatf("{{ reg.name }} mismatch: wrote 0x%0h, read 0x%0h", wdata, rdata))
        else
            `uvm_info(get_type_name(), $sformatf("{{ reg.name }} OK: 0x%0h", rdata), UVM_MEDIUM)
        
{% endif %}
{% endfor %}
    endtask
    
endclass : {{ prefix }}_wr_rd_seq
{% endif %}
