//------------------------------------------------------------------------------
// APB Sequence Item - Generated by UVMForge
//------------------------------------------------------------------------------

class {{ prefix }}_seq_item extends uvm_sequence_item;
    
    // Transaction fields
    rand bit [{{ addr_width }}-1:0]  addr;
    rand bit [{{ data_width }}-1:0]  data;
    rand apb_trans_type_e            trans_type;
{% if apb_version >= 4 %}
    rand bit [{{ strb_width }}-1:0]  strb;
{% endif %}
    
    // Response fields (filled by driver/monitor)
    bit [{{ data_width }}-1:0]       rdata;
    apb_resp_type_e                  resp;
    
    // Constraints
    constraint addr_align_c {
        addr[1:0] == 2'b00;  // Word aligned
    }
    
{% if apb_version >= 4 %}
    constraint strb_valid_c {
        trans_type == APB_WRITE -> strb != 0;
        trans_type == APB_READ  -> strb == '1;
    }
{% endif %}

{% if has_registers %}
    // Register address constraints
    constraint valid_addr_c {
        addr inside {
{% for reg in registers %}
            {{ reg.address_hex }}{% if not loop.last %},{% endif %}

{% endfor %}
        };
    }
{% endif %}
    
    // UVM automation macros
    `uvm_object_utils_begin({{ prefix }}_seq_item)
        `uvm_field_int(addr, UVM_ALL_ON)
        `uvm_field_int(data, UVM_ALL_ON)
        `uvm_field_enum(apb_trans_type_e, trans_type, UVM_ALL_ON)
{% if apb_version >= 4 %}
        `uvm_field_int(strb, UVM_ALL_ON)
{% endif %}
        `uvm_field_int(rdata, UVM_ALL_ON)
        `uvm_field_enum(apb_resp_type_e, resp, UVM_ALL_ON)
    `uvm_object_utils_end
    
    // Constructor
    function new(string name = "{{ prefix }}_seq_item");
        super.new(name);
    endfunction
    
    // Convert to string for debug
    virtual function string convert2string();
        return $sformatf("%s: addr=0x%0h data=0x%0h rdata=0x%0h resp=%s",
                        trans_type.name(), addr, data, rdata, resp.name());
    endfunction
    
endclass : {{ prefix }}_seq_item
