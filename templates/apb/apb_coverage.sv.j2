//------------------------------------------------------------------------------
// APB Coverage - Generated by VerifAI
//------------------------------------------------------------------------------

class {{ prefix }}_coverage extends uvm_subscriber #({{ prefix }}_seq_item);
    
    `uvm_component_utils({{ prefix }}_coverage)
    
    // Transaction for coverage sampling
    {{ prefix }}_seq_item txn;
    
    // Covergroups
    covergroup apb_cg;
        option.per_instance = 1;
        option.name = "apb_coverage";
        
        // Transaction type coverage
        trans_type_cp: coverpoint txn.trans_type {
            bins read  = {APB_READ};
            bins write = {APB_WRITE};
        }
        
        // Address coverage
        address_cp: coverpoint txn.addr {
{% for reg in registers %}
            bins {{ reg.name_lower }} = {{ '{' }}{{ reg.address_hex }}{{ '}' }};
{% endfor %}
            bins other = default;
        }
        
        // Data coverage
        data_cp: coverpoint txn.data {
            bins zero     = {0};
            bins all_ones = {{ '{' }}{{ data_width }}{{ '{' }}1'b1{{ '}' }}{{ '}' }};
            bins low      = {[1:32'h0000_FFFF]};
            bins mid      = {[32'h0001_0000:32'h7FFF_FFFF]};
            bins high     = {[32'h8000_0000:32'hFFFF_FFFE]};
        }
        
        // Response coverage
        response_cp: coverpoint txn.resp {
            bins okay  = {APB_OKAY};
            bins error = {APB_ERROR};
        }
        
        // Cross coverage: Address x Transaction Type
        addr_x_type: cross address_cp, trans_type_cp {
{% for reg in registers %}
{% if not reg.is_writable %}
            // {{ reg.name }} is read-only, ignore writes
            ignore_bins {{ reg.name_lower }}_write = binsof(address_cp.{{ reg.name_lower }}) && binsof(trans_type_cp.write);
{% endif %}
{% if not reg.is_readable %}
            // {{ reg.name }} is write-only, ignore reads
            ignore_bins {{ reg.name_lower }}_read = binsof(address_cp.{{ reg.name_lower }}) && binsof(trans_type_cp.read);
{% endif %}
{% endfor %}
        }
        
    endgroup
    
    // Back-to-back coverage
    covergroup apb_b2b_cg;
        option.per_instance = 1;
        option.name = "apb_back2back";
        
        b2b_type_cp: coverpoint txn.trans_type {
            bins rd_rd = (APB_READ  => APB_READ);
            bins rd_wr = (APB_READ  => APB_WRITE);
            bins wr_rd = (APB_WRITE => APB_READ);
            bins wr_wr = (APB_WRITE => APB_WRITE);
        }
    endgroup
    
    // Constructor
    function new(string name = "{{ prefix }}_coverage", uvm_component parent = null);
        super.new(name, parent);
        apb_cg = new();
        apb_b2b_cg = new();
    endfunction
    
    // Write function - called when transaction received
    virtual function void write({{ prefix }}_seq_item t);
        txn = t;
        apb_cg.sample();
        apb_b2b_cg.sample();
    endfunction
    
    // Report coverage
    virtual function void report_phase(uvm_phase phase);
        `uvm_info(get_type_name(), "========== COVERAGE SUMMARY ==========", UVM_NONE)
        `uvm_info(get_type_name(), $sformatf("  APB Coverage:     %.2f%%", apb_cg.get_coverage()), UVM_NONE)
        `uvm_info(get_type_name(), $sformatf("  Back2Back Cov:    %.2f%%", apb_b2b_cg.get_coverage()), UVM_NONE)
        `uvm_info(get_type_name(), "======================================", UVM_NONE)
    endfunction
    
endclass : {{ prefix }}_coverage
